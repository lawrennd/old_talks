---
title: "The NeurIPS Experiment"
venue: "Swiss National Science Foundation"
abstract: "<p>In 2014, along with Corinna Cortes, I was Program Chair of the Neural Information Processing Systems conference. At the time, when wondering about innovations for the conference, Corinna and I decided it would be interesting to test the consistency of reviewing. With this in mind, we randomly selected 10% of submissions and had them reviewed by two independent committees. In this talk I will briefly review the construction of the experiment, explain how the NeurIPS review process worked and talk about what I felt the implications for reviewing were, vs what the community reaction was.</p>"
author:
- given: Neil D.
  family: Lawrence
  url: http://inverseprobability.com
  institute: University of Cambridge
  twitter: lawrennd
  gscholar: r3SJcvoAAAAJ
  orcid: 
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_neurips/the-neurips-experiment-snsf.md
date: 2022-05-10
published: 2022-05-10
week: 0
reveal: 2022-05-10-the-neurips-experiment-snsf.slides.html
ipynb: 2022-05-10-the-neurips-experiment-snsf.ipynb
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_neurips/the-neurips-experiment-snsf.md
layout: talk
categories:
- notes
---



<!-- Do not edit this file locally. -->
<!---->
<!-- Do not edit this file locally. -->
<!-- Do not edit this file locally. -->
<!-- The last names to be defined. Should be defined entirely in terms of macros from above-->
<!--

-->
<h1 id="introduction">Introduction</h1>
<p>The NIPS experiment was an experiment to determine the consistency of the review process. After receiving papers, we selected 10% that would be independently rereviewed. The idea was to determine how consistent the decisions between the two sets of independent papers would be. In 2014 NIPS received 1678 submissions and we selected 170 for the experiment. These papers are referred to below as ‘duplicated papers.’</p>
<p>To run the experiment, we created two separate committees within the NIPS program committee. The idea was that the two separate committees would review each duplicated paper independently and results compared.</p>
<h2 id="neurips-in-numbers">NeurIPS in Numbers</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-in-numbers.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-in-numbers.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In 2014 the NeurIPS conference had 1474 active reviewers (up from 1133 in 2013), 92 area chairs (up from 67 in 2013) and two program chairs, Corinna Cortes and me.</p>
<p>The conference received 1678 submissions and presented 414 accepted papers, of which 20 were presented as talks in the single-track session, 62 were presented as spotlights and 331 papers were presented as posters. Of the 1678 submissions, 19 papers were rejected without review.</p>
<h2 id="the-neurips-experiment">The NeurIPS Experiment</h2>
<p>The objective of the NeurIPS experiment was to determine how consistent the process of peer review is. One way of phrasing this question is to ask: what would happen to submitted papers in the conference if the process was independently rerun?</p>
<p>For the 2014 conference, to explore this question, we selected <span class="math inline">\(\approx 10\%\)</span> of submitted papers to be reviewed twice, by independent committees. This led to 170 papers being selected from the conference for dual reviewing. For these papers the program committee was divided into two. Reviewers were placed randomly on one side of the committee or the other. For Program Chairs we also engaged in some manual selection to ensure we had expert coverage in all the conference areas on both side of the committee.</p>
<h2 id="timeline-for-neurips">Timeline for NeurIPS</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-timeline.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-timeline.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Chairing a conference starts with recruitment of the program committee, which is usually done in a few stages. The primary task is to recruit the area chairs. We sent out our program committee invites in three waves.</p>
<ul>
<li>17/02/2014</li>
<li>08/03/2014</li>
<li>09/04/2014</li>
</ul>
<p>By recruiting area chairs first, you can involve them in recruiting reviewers. We requested names of reviewers from ACs in two waves.</p>
<ul>
<li>25/03/2014</li>
<li>11/04/2014</li>
</ul>
<p>In 2014, this wasn’t enough to obtain the requisite number of reviewers, so we used additional approaches. These included lists of previous NeurIPS authors. For each individual we were looking for at least two previously-published papers from NeurIPS and other leading leading ML venues like ICML, AISTATS, COLT, UAI etc.. We made extensive use of <a href="https://dblp.uni-trier.de/">DBLP</a> for verifying each potential reviewer’s publication track record.</p>
<ul>
<li>14/04/2014</li>
<li>28/04/2014</li>
<li>09/05/2014</li>
<li>10/06/2014 (note this is after deadline … lots of area chairs asked for reviewers after the deadline!). We invited them en-masse.</li>
</ul>
<ul>
<li>06/06/2014 Submission Deadline</li>
<li>12/06/2014 Bidding Open for Area Chairs (this was <em>delayed</em> by CMT issues)</li>
<li>17/06/2014 Bidding Open for Reviewers</li>
<li>01/07/2014 Start Reviewing</li>
<li>21/07/2014 Reviewing deadline</li>
<li>04/08/2014 Reviews to Authors</li>
<li>11/08/2014 Author Rebuttal Due</li>
<li>25/08/2014 Teleconferences Begin</li>
<li>30/08/2014 Teleconferences End</li>
<li>1/09/2014 Preliminary Decisions Made</li>
<li>9/09/2014 Decisions Sent to Authors</li>
</ul>
<h2 id="paper-scoring-and-reviewer-instructions">Paper Scoring and Reviewer Instructions</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/paper-scoring.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/paper-scoring.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>The instructions to reviewers for the 2014 conference are still available <a href="https://nips.cc/Conferences/2014/PaperInformation/ReviewerInstructions">online here</a>.</p>
<p>To keep quality of reviews high, we tried to keep load low. We didn’t assign any reviewer more than 5 papers, most reviewers received 4 papers.</p>
<h2 id="quantitative-evaluation">Quantitative Evaluation</h2>
<p>Reviewers give a score of between 1 and 10 for each paper. The program committee will interpret the numerical score in the following way:</p>
<ul>
<li><p>10: Top 5% of accepted NIPS papers, a seminal paper for the ages.</p>
<p>I will consider not reviewing for NIPS again if this is rejected.</p></li>
<li><p>9: Top 15% of accepted NIPS papers, an excellent paper, a strong accept.</p>
<p>I will fight for acceptance.</p></li>
<li><p>8: Top 50% of accepted NIPS papers, a very good paper, a clear accept.</p>
<p>I vote and argue for acceptance.</p></li>
<li><p>7: Good paper, accept.</p>
<p>I vote for acceptance, although would not be upset if it were rejected.</p></li>
<li><p>6: Marginally above the acceptance threshold.</p>
<p>I tend to vote for accepting it, but leaving it out of the program would be no great loss.</p></li>
<li><p>5: Marginally below the acceptance threshold.</p>
<p>I tend to vote for rejecting it, but having it in the program would not be that bad.</p></li>
<li><p>4: An OK paper, but not good enough. A rejection.</p>
<p>I vote for rejecting it, although would not be upset if it were accepted.</p></li>
<li><p>3: A clear rejection.</p>
<p>I vote and argue for rejection.</p></li>
<li><p>2: A strong rejection. I’m surprised it was submitted to this conference.</p>
<p>I will fight for rejection.</p></li>
<li><p>1: Trivial or wrong or known. I’m surprised anybody wrote such a paper.</p>
<p>I will consider not reviewing for NIPS again if this is accepted.</p></li>
</ul>
<p>Reviewers should NOT assume that they have received an unbiased sample of papers, nor should they adjust their scores to achieve an artificial balance of high and low scores. Scores should reflect absolute judgments of the contributions made by each paper.</p>
<h2 id="impact-score">Impact Score</h2>
<p>The impact score was an innovation introduce in 2013 by Ghahramani and Welling that we retained for 2014. Quoting from the instructions to reviewers:</p>
<blockquote>
<p>Independently of the Quality Score above, this is your opportunity to identify papers that are very different, original, or otherwise potentially impactful for the NIPS community.</p>
<p>There are two choices:</p>
<p>2: This work is different enough from typical submissions to potentially have a major impact on a subset of the NIPS community.</p>
<p>1: This work is incremental and unlikely to have much impact even though it may be technically correct and well executed.</p>
<p>Examples of situations where the impact and quality scores may point in opposite directions include papers which are technically strong but unlikely to generate much follow-up research, or papers that have some flaw (e.g. not enough evaluation, not citing the right literature) but could lead to new directions of research.</p>
</blockquote>
<h2 id="confidence-score">Confidence Score</h2>
<p>Reviewers also give a confidence score between 1 and 5 for each paper. The program committee will interpret the numerical score in the following way:</p>
<p>5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature.</p>
<p>4: The reviewer is confident but not absolutely certain that the evaluation is correct. It is unlikely but conceivable that the reviewer did not understand certain parts of the paper, or that the reviewer was unfamiliar with a piece of relevant literature.</p>
<p>3: The reviewer is fairly confident that the evaluation is correct. It is possible that the reviewer did not understand certain parts of the paper, or that the reviewer was unfamiliar with a piece of relevant literature. Mathematics and other details were not carefully checked.</p>
<p>2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper.</p>
<p>1: The reviewer’s evaluation is an educated guess. Either the paper is not in the reviewer’s area, or it was extremely difficult to understand.</p>
<h2 id="qualitative-evaluation">Qualitative Evaluation</h2>
<p>All NIPS papers should be good scientific papers, regardless of their specific area. We judge whether a paper is good using four criteria; a reviewer should comment on all of these, if possible:</p>
<ul>
<li><p>Quality</p>
<p>Is the paper technically sound? Are claims well-supported by theoretical analysis or experimental results? Is this a complete piece of work, or merely a position paper? Are the authors careful (and honest) about evaluating both the strengths and weaknesses of the work?</p></li>
<li><p>Clarity</p>
<p>Is the paper clearly written? Is it well-organized? (If not, feel free to make suggestions to improve the manuscript.) Does it adequately inform the reader? (A superbly written paper provides enough information for the expert reader to reproduce its results.)</p></li>
<li><p>Originality</p>
<p>Are the problems or approaches new? Is this a novel combination of familiar techniques? Is it clear how this work differs from previous contributions? Is related work adequately referenced? We recommend that you check the proceedings of recent NIPS conferences to make sure that each paper is significantly different from papers in previous proceedings. Abstracts and links to many of the previous NIPS papers are available from http://books.nips.cc</p></li>
<li><p>Significance</p></li>
</ul>
<p>Are the results important? Are other people (practitioners or researchers) likely to use these ideas or build on them? Does the paper address a difficult problem in a better way than previous research? Does it advance the state of the art in a demonstrable way? Does it provide unique data, unique conclusions on existing data, or a unique theoretical or pragmatic approach?</p>
<!--




## Speculation

<div style="text-align:right"><span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-speculation.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-speculation.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></div>



With the help of [Nicolo Fusi](http://nicolofusi.com/), [Charles Twardy](http://blog.scicast.org/tag/charles-twardy/) and the entire Scicast team we launched [a Scicast question](https://scicast.org/#!/questions/1083/trades/create/power) a week before the results were revealed. The comment thread for that question already had [an amount of interesting comment](https://scicast.org/#!/questions/1083/comments/power) before the conference. Just for informational purposes before we began reviewing Corinna forecast this figure would be 25% and I forecast it would be 20%. The box plot summary of predictions from Scicast is below.



<div class="figure">
<div class="figure-frame" id="scicast-forecast-figure">
<div class="centered " style=""><img class="" src="https://inverseprobability.com/talks/./slides/diagrams//neurips/scicast-forecast.png" width="40%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle"></div>
</div>
<div class="magnify" id="scicast-forecast-magnify" onclick="magnifyFigure('scicast-forecast')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="scicast-forecast-caption">
Figure: Summary forecast from those that responded to a scicast question about how consistent the decision making was.
</div>
</div>



-->
<h2 id="neurips-experiment-results">NeurIPS Experiment Results</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-results.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-results.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>The results of the experiment were as follows. From 170 papers 4 had to be withdrawn or were rejected without completing the review process, for the remainder, the ‘confusion matrix’ for the two committee’s decisions is in Table .</p>
<div class="table">
<div id="table-neurips-experiment-results-caption" class="caption-frame">
<p>Table: Table showing the results from the two committees as a confusion matrix. Four papers were rejected or withdrawn without review.</p>
</div>
<div id="table-neurips-experiment-results-table" class="table-frame">
<table>
<tr>
<td colspan="2">
</td>
<td colspan="2">
Committee 1
</td>
</tr>
<tr>
<td colspan="2">
</td>
<td>
Accept
</td>
<td>
Reject
</td>
</tr>
<tr>
<td rowspan="2">
Committee 2
</td>
<td>
Accept
</td>
<td>
22
</td>
<td>
22
</td>
</tr>
<tr>
<td>
Reject
</td>
<td>
21
</td>
<td>
101
</td>
</tr>
</table>
</div>
<div id="table-neurips-experiment-results-magnify" class="magnify" onclick="magnifyFigure(&#39;table-neurips-experiment-results&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
</div>
<h2 id="summarizing-the-table">Summarizing the Table</h2>
<p>There are a few ways of summarizing the numbers in this table as percent or probabilities. First, the inconsistency, the proportion of decisions that were not the same across the two committees. The decisions were inconsistent for 43 out of 166 papers or 0.259 as a proportion. This number is perhaps a natural way of summarizing the figures if you are submitting your paper and wish to know an estimate of what the probability is that your paper would have different decisions according to the different committees. Secondly, the accept precision: if you are attending the conference and looking at any given paper, then you might want to know the probability that the paper would have been rejected in an independent rerunning of the conference. We can estimate this for Committee 1’s conference as 22/(22 + 22) = 0.5 (50%) and for Committee 2’s conference as 21/(22+21) = 0.49 (49%). Averaging the two estimates gives us 49.5%. Finally, the reject precision: if your paper was rejected from the conference, you might like an estimate of the probability that the same paper would be rejected again if the review process had been independently rerun. That estimate is 101/(22+101) = 0.82 (82%) for Committee 1 and 101/(21+101)=0.83 (83%) for Committee 2, or on average 82.5%. A final quality estimate might be the ratio of consistent accepts to consistent rejects, or the agreed accept rate, 22/123 = 0.18 (18%).</p>
<ul>
<li><em>inconsistency</em>: 43/166 = <strong>0.259</strong>
<ul>
<li>proportion of decisions that were not the same</li>
</ul></li>
<li><em>accept precision</em> <span class="math inline">\(0.5 \times 22/44\)</span> + <span class="math inline">\(0.5 \times 21/43\)</span> = <strong>0.495</strong>
<ul>
<li>probability any accepted paper would be rejected in a rerunning</li>
</ul></li>
<li><em>reject precision</em> = <span class="math inline">\(0.5\times 101/(22+101)\)</span> + <span class="math inline">\(0.5\times 101/(21 + 101)\)</span> = <strong>0.175</strong>
<ul>
<li>probability any rejected paper would be rejected in a rerunning</li>
</ul></li>
<li><em>agreed accept rate</em> = 22/101 = <strong>0.218</strong></li>
<li>ratio between agreed accepted papers and agreed rejected papers.</li>
</ul>
<!--




## Reaction After Experiment

<div style="text-align:right"><span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-reaction.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-reaction.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></div>



There seems to have been a lot of discussion of the result, both at the conference and on bulletin boards since. Such discussion is to be encouraged, and for ease of memory, it is worth pointing out that the approximate proportions of papers in each category can be nicely divided in to eighths as follows. Accept-Accept 1 in 8 papers, Accept-Reject 3 in 8 papers, Reject-Reject, 5 in 8 papers. This makes the statistics we've computed above: inconsistency 1 in 4 (25%) accept precision 1 in 2 (50%) reject precision 5 in 6 (83%) and agreed accept rate of 1 in 6 (20%). This compares with the accept rate of 1 in 4.


* Public reaction after experiment [documented here](http://inverseprobability.com/2015/01/16/blogs-on-the-nips-experiment/)

* [Open Data Science](http://inverseprobability.com/2014/07/01/open-data-science/) (see Heidelberg Meeting)

* NIPS was run in a very open way. [Code](https://github.com/sods/conference) and [blog posts](http://inverseprobability.com/2014/12/16/the-nips-experiment/) all available! 

* Reaction triggered by [this blog post](http://blog.mrtz.org/2014/12/15/the-nips-experiment.html). 

Much of the discussion speculates on the number of consistent accepts in the process (using the main conference accept rate as a proxy). It therefore produces numbers that don't match ours above. This is because the computed accept rate of the individual committees is different from that of the main conference. This could be due to a bias for the duplicated papers, or statistical sampling error. We look at these questions below. First, to get the reader primed for thinking about these numbers we discuss some context for placing these numbers.


-->
<!--




## A Random Committee @ 25%

<div style="text-align:right"><span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-random-committee.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-random-committee.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></div>



The first context we can place around the numbers is what would have happened at the 'Random Conference' where we simply accept a quarter of papers at random. In this NIPS the expected numbers of accepts would then have been given as in Table \ref{table-random-committee}.

<div class="table">
<div class="caption-frame" id="table-random-committee-caption">
Table: Table shows the expected values for the confusion matrix if the committee was making decisions totally at random.
</div>
<div class="table-frame" id="table-random-committee-table">
<table>
  <tr>
  <td colspan="2"></td><td colspan="2">Committee 1</td>
  </tr>
  <tr>
  <td colspan="2"></td><td>Accept</td><td>Reject</td>
  </tr>
  <tr>
    <td rowspan="2">Committee 2</td><td>Accept</td><td>10.4 (1 in 16)</td><td>31.1 (3 in 16)</td>
  </tr>
  <tr>
    <td>Reject</td><td>31.1 (3 in 16) </td><td>93.4 (9 in 16)</td>
  </tr>
  </table>
  
</div>
<div class="magnify" id="table-random-committee-magnify" onclick="magnifyFigure('table-random-committee')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
</div>
  











And for this set up we would expect *inconsistency* of 3 in 8 (37.5%) *accept precision* of 1 in 4 (25%) and a *reject precision* of 3 in 4 (75%) and a *agreed accept rate* of 1 in 10 (10%). The actual committee made improvements on these numbers, the accept precision was markedly better with 50%: twice as many consistent accept decisions were made than would be expected if the process had been performed at random and only around two thirds as many inconsistent decisions were made as would have been expected if decisions were made at random. However, we should treat all these figures with some skepticism until we've performed some estimate of the uncertainty associated with them.


## Stats for Random Committee





* For random committee we expect:
  * *inconsistency* of 3 in 8 (37.5%) 
  * *accept precision* of 1 in 4 (25%) 
  * *reject precision* of 3 in 4 (75%) and a 
  * *agreed accept rate* of 1 in 10 (10%). 

Actual committee's accept precision markedly better with 50% accept precision.

## Uncertainty: Accept Rate





To get a handle on the uncertainty around these numbers we'll start by making use of the <a href="http://en.wikipedia.org/wiki/Binomial_distribution" target="_blank">binomial distribution</a>. First, let's explore the fact that for the overall conference the accept rate was around 23%, but for the duplication committees the accept rate was around 25%. If we assume decisions are made according to a binomial distribution, then is the accept rate for the duplicated papers too high?

Note that for all our accept probability statistics we used as a denominator the number of papers that were initially sent for review, rather than the number where a final decision was made by the program committee. These numbers are different because some papers are withdrawn before the program committee makes its decision. Most commonly this occurs after authors have seen their preliminary reviews: for NIPS 2014 we provided preliminary reviews that included paper scores. So for the official accept probability we use the 170 as denominator. The accept probabilities were therefore 43 out of 170 papers (25.3%) for Committee 1 and 44 out of 170 (25.8%) for Committee 2. This compares with the overall conference accept rate for papers outside the duplication process of 349 out of 1508 (23.1%).

If the true underlying probability of an accept were 0.23, independent of the paper, then the probability of generating accepts for any subset of the papers would be given by a binomial distribution. Combining across the two committees for the duplicated papers, we see that 87 papers in total were recommended for accept out of a total of 340 trials. out of 166 trials would be given by a binomial distribution as depicted below.

```{.python}
import numpy as np
from scipy.stats import binom
from IPython.display import HTML
```





<div class="figure">
<div class="figure-frame" id="uncertainty-accept-rate-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/uncertainty-accept-rate.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="uncertainty-accept-rate-magnify" onclick="magnifyFigure('uncertainty-accept-rate')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="uncertainty-accept-rate-caption">
Figure: Number of accepted papers for $p=0.23$.
</div>
</div>

From the plot, we can see that whilst the accept rate was slightly higher for duplicated papers it doesn't seem that we can say that it was statistically significant that it was higher, it falls well within the probability mass of the Binomial.

Note that Area Chairs knew which papers were duplicates, whereas reviewers did not. Whilst we stipulated that duplicate papers should not be any given special treatment, we cannot discount the possibility that Area Chairs may have given slightly preferential treatment to duplicate papers.

## Uncertainty: Accept Precision





For the accept precision, if we assume that accept decisions were drawn according to a binomial, then the distribution for consistent accepts is also binomial. Our best estimate of its parameter is 22/166 = 0.13 (13%). If we had a binomial distribution with these parameters, then the distribution of consistent accepts would be as follows.





<div class="figure">
<div class="figure-frame" id="uncertainty-accept-precision-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/uncertainty-accept-rate.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="uncertainty-accept-precision-magnify" onclick="magnifyFigure('uncertainty-accept-precision')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="uncertainty-accept-precision-caption">
Figure: Number of consistent accepts given $p=0.13$.
</div>
</div>

We see immediately that there is a lot of uncertainty around this number, for the scale of the experiment as we have it. This suggests a more complex analysis is required to extract our estimates with uncertainty.

## Bayesian Analysis





Before we start the analysis, it's important to make some statements about the aims of our modelling here. We will make some simplifying modelling assumptions for the sake of a model that is understandable. We are looking to get a handle on the uncertainty associated with some of the probabilities associated with the NIPS experiment. [Some preliminary analyses have already been conducted on blogs](http://inverseprobability.com/2015/01/16/blogs-on-the-nips-experiment/). Those analyses don't have access to information like paper scores etc. For that reason we also leave out such information in this preliminary analysis. We will focus only on the summary results from the experiment: how many papers were consistently accepted, consistently rejected, or had inconsistent decisions. For the moment we disregard the information we have about paper scores.


In our analysis there are three possible outcomes for each paper: consistent accept, inconsistent decision and consistent reject. So, we need to perform the analysis with the [multinomial distribution](http://en.wikipedia.org/wiki/Multinomial_distribution). The multinomial is parameterized by the probabilities of the different outcomes. These are our parameters of interest; we would like to estimate these probabilities alongside their uncertainties. To make a Bayesian analysis we place a prior density over these probabilities, then we update the prior with the observed data, that gives us a posterior density, giving us an uncertainty associated with these probabilities.



### Prior Density





Choice of prior for the multinomial is typically straightforward, the [Dirichlet density](http://en.wikipedia.org/wiki/Dirichlet_distribution) is [conjugate](http://en.wikipedia.org/wiki/Conjugate_prior) and has the additional advantage that its parameters can be set to ensure it is *uninformative*, i.e. uniform across the domain of the prior. Combination of a multinomial likelihood and a Dirichlet prior is not new, and in this domain if we were to consider the mean the posterior density only, then the approach is known as [Laplace smoothing](http://en.wikipedia.org/wiki/Additive_smoothing). 

For our model we are assuming for our prior that the probabilities are drawn from a Dirichlet as follows,
$$
p \sim \text{Dir}(\alpha_1, \alpha_2, \alpha_3),
$$
with $\alpha_1=\alpha_2=\alpha_3=1$. The Dirichlet density is conjugate to the [multinomial distribution](http://en.wikipedia.org/wiki/Multinomial_distribution), and we associate three different outcomes with the multinomial. For each of the 166 papers we expect to have a consistent accept (outcome 1), an inconsistent decision (outcome 2) or a consistent reject (outcome 3). If the counts four outcome 1, 2 and 3 are represented by $k_1$, $k_2$ and $k_3$ and the associated probabilities are given by $p_1$, $p_2$ and $p_3$ then our model is, 
\begin{align*}
\mathbf{p}|\boldsymbol{\alpha} \sim \text{Dir}(\boldsymbol{\alpha}) \\
\mathbf{k}|\mathbf{p} \sim \text{mult}(\mathbf{p}).
\end{align*}
Due to the conjugacy the posterior is tractable and easily computed as a Dirichlet (see e.g. [Gelman et al](http://www.stat.columbia.edu/~gelman/book/)), where the parameters of the Dirichlet are given by the original vector from the Dirichlet prior plus the counts associated with each outcome. 
$$
\mathbf{p}|\mathbf{k}, \boldsymbol{\alpha} \sim \text{Dir}(\boldsymbol{\alpha} + \mathbf{k})
$$
The mean probability for each outcome is then given by,
$$
\bar{p}_i = \frac{\alpha_i+k_i}{\sum_{j=1}^3(\alpha_j + k_j)}.
$$
and the variance is
$$
\mathrm{Var}[p_i] = \frac{(\alpha_i+k_i) (\alpha_0-\alpha_i + n + k_i)}{(\alpha_0+n)^2 (\alpha_0+n+1)},
$$
where $n$ is the number of trials (166 in our case) and $\alpha_0 = \sum_{i=1}^3\alpha_i$. This allows us to compute the expected value of the probabilities and their variances under the posterior as follows.

```{.python}
def posterior_mean_var(k, alpha):
    """Compute the mean and variance of the Dirichlet posterior."""
    alpha_0 = alpha.sum()
    n = k.sum()
    m = (k + alpha)
    m /= m.sum()
    v = (alpha+k)*(alpha_0 - alpha + n + k)/((alpha_0+n)**2*(alpha_0+n+1))
    return m, v

k = np.asarray([22, 43, 101])
alpha = np.ones((3,))
m, v = posterior_mean_var(k, alpha)
outcome = ['consistent accept', 'inconsistent decision', 'consistent reject']
for i in range(3):
    display(HTML("<h4>Probability of " + outcome[i] +' ' + str(m[i]) +  "+/-" + str(2*np.sqrt(v[i])) + "</h4>"))
```

So we have a probability of consistent accept as $0.136 \pm 0.06$, the probability of inconsistent decision as $0.260 \pm 0.09$ and probability of consistent reject as $0.60 \pm 0.15$. Recall that if we'd selected papers at random (with accept rate of 1 in 4) then these values would have been 1 in 16 (0.0625), 3 in 8 (0.375) and 9 in 16 (0.5625). 

The other values we are interested in are the accept precision, reject precision and the agreed accept rate. Computing the probability density for these statistics is complex: it involves [Ratio Distributions](http://en.wikipedia.org/wiki/Ratio_distribution). However, we can use Monte Carlo to estimate the expected accept precision, reject precision, and agreed accept rate as well as their variances. We can use these results to give us error bars and histograms of these statistics.

```{.python}
def sample_precisions(k, alpha, num_samps):
    """Helper function to sample from the posterior distibution of accept, 
    reject and inconsistent probabilities and compute other statistics of interest 
    from the samples."""

    k = np.random.dirichlet(k+alpha, size=num_samps)
    # Factors of 2 appear because inconsistent decisions 
    # are being accounted for across both committees.
    ap = 2*k[:, 0]/(2*k[:, 0]+k[:, 1])
    rp = 2*k[:, 2]/(k[:, 1]+2*k[:, 2])
    aa = k[:, 0]/(k[:, 0]+k[:, 2])
    return ap, rp, aa

ap, rp, aa = sample_precisions(k, alpha, 10000)
print(ap.mean(), '+/-', 2*np.sqrt(ap.var()))
print(rp.mean(), '+/-', 2*np.sqrt(rp.var()))
print(aa.mean(), '+/-', 2*np.sqrt(aa.var()))
```

Giving an accept precision of $0.51 \pm 0.13$, a reject precision of $0.82 \pm 0.05$ and an agreed accept rate of $0.18 \pm 0.07$. Note that the 'random conference' values of 1 in 4 for accept precision and 3 in 4 for reject decisions are outside the two standard deviation error bars. If it is preferred medians and percentiles could also be computed from the samples above, but as we will see when we histogram the results the densities look broadly symmetric, so this is unlikely to have much effect.

### Histogram of Monte Carlo Results





Just to ensure that the error bars are reflective of the underlying densities we histogram the Monte Carlo results for accept precision, reject precision and agreed accept below. Shown on each histogram is a line representing the result we would get for the 'random committee'.



<div class="figure">
<div class="figure-frame" id="random-committee-outcomes-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/random-committee-outcomes-vs-true.svg" width="90%" style=" "></object>
</div>
<div class="magnify" id="random-committee-outcomes-magnify" onclick="magnifyFigure('random-committee-outcomes')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="random-committee-outcomes-caption">
Figure: Different statistics for the random committee oucomes versus the observed committee outcomes.
</div>
</div>

### Model Choice and Prior Values





In the analysis above we've minimized the modeling choices: we made use of a Bayesian analysis to capture the uncertainty in counts that can be arising from statistical sampling error. To this end we chose an uninformative prior over these probabilities. However, one might argue that the prior should reflect something more about the underlying experimental structure: for example, we *know* that if the committees made their decisions independently it is unlikely that we'd obtain an inconsistency figure much greater than 37.5% because that would require committees to explicitly collude to make inconsistent decisions: the random conference is the worst case. Due to the accept rate, we also expect a larger number of reject decisions than reject. This also isn't captured in our prior. Such questions move us into the realms of modeling the process, rather than performing a sensitivity analysis. However, if we wish to model the decision process as a whole, we have a lot more information available, and we should make use of it. The analysis above is intended to exploit our randomized experiment to explore how inconsistent we expect two committees to be. It focusses on that single question; it doesn't attempt to give answers on what the reasons for that inconsistency are and how it may be reduced. The additional maths was needed only to give a sense of the uncertainty in the figures. That uncertainty arises due to the limited number of papers in the experiment.



-->
<!--include{_neurips/includes/neurips-experiment.md}-->
<h2 id="reviewer-calibration">Reviewer Calibration</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-reviewer-calibration.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-reviewer-calibration.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Calibration of reviewers is the process where different interpretations of the reviewing scale are addressed. The tradition of calibration goes at least as far back as John Platt’s Program Chairing, and included a Bayesian model by Ge, Welling and Ghahramani at NeurIPS 2013.</p>
<h2 id="reviewer-calibration-model">Reviewer Calibration Model</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/reviewer-calibration-model.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/reviewer-calibration-model.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>In this note book we deal with reviewer calibration. Our assumption is that the score from the <span class="math inline">\(j\)</span>th reviwer for the <span class="math inline">\(i\)</span>th paper is given by <span class="math display">\[
y_{i,j} = f_i + b_j + \epsilon_{i, j}
\]</span> where <span class="math inline">\(f_i\)</span> is the ‘objective quality’ of paper <span class="math inline">\(i\)</span> and <span class="math inline">\(b_j\)</span> is an offset associated with reviewer <span class="math inline">\(j\)</span>. <span class="math inline">\(\epsilon_{i,j}\)</span> is a subjective quality estimate which reflects how a specific reviewer’s opinion differs from other reviewers (such differences in opinion may be due to differing expertise or perspective). The underlying ‘objective quality’ of the paper is assumed to be the same for all reviewers and the reviewer offset is assumed to be the same for all papers.</p>
<p>If we have <span class="math inline">\(n\)</span> papers and <span class="math inline">\(m\)</span> reviewers, then this implies <span class="math inline">\(n\)</span> + <span class="math inline">\(m\)</span> + <span class="math inline">\(nm\)</span> values need to be estimated. Naturally this is too many, and we can start by assuming that the subjective quality is drawn from a normal density with variance <span class="math inline">\(\sigma^2\)</span> <span class="math display">\[
\epsilon_{i, j} \sim N(0, \sigma^2 \mathbf{I})
\]</span> which reduces us to <span class="math inline">\(n\)</span> + <span class="math inline">\(m\)</span> + 1 parameters. Further we can assume that the objective quality is also normally distributed with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\alpha_f\)</span>, <span class="math display">\[
f_i \sim N(\mu, \alpha_f)
\]</span> this now reduces us to <span class="math inline">\(m\)</span>+3 parameters. However, we only have approximately <span class="math inline">\(4m\)</span> observations (4 papers per reviewer) so parameters may still not be that well determined (particularly for those reviewers that have only one review). We, therefore, finally, assume that reviewer offset is normally distributed with zero mean, <span class="math display">\[
b_j \sim N(0, \alpha_b),
\]</span> leaving us only four parameters: <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma^2\)</span>, <span class="math inline">\(\alpha_f\)</span> and <span class="math inline">\(\alpha_b\)</span>. Combined together these three assumptions imply that <span class="math display">\[
\mathbf{y} \sim N(\mu \mathbf{1}, \mathbf{K}),
\]</span> where <span class="math inline">\(\mathbf{y}\)</span> is a vector of stacked scores <span class="math inline">\(\mathbf{1}\)</span> is the vector of ones and the elements of the covariance function are given by <span class="math display">\[
k(i,j; k,l) = \delta_{i,k} \alpha_f + \delta_{j,l} \alpha_b + \delta_{i, k}\delta_{j,l} \sigma^2,
\]</span> where <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are the index of first paper and reviewer and <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span> are the index of second paper and reviewer. The mean is easily estimated by maximum likelihood and is given as the mean of all scores.</p>
<p>It is convenient to reparametrize slightly into an overall scale <span class="math inline">\(\alpha_f\)</span>, and normalized variance parameters, <span class="math display">\[
k(i,j; k,l) = \alpha_f\left(\delta_{i,k}  + \delta_{j,l} \frac{\alpha_b}{\alpha_f} + \delta_{i, k}\delta_{j,l} \frac{\sigma^2}{\alpha_f}\right)
\]</span> which we rewrite to give two ratios: offset/signal ratio, <span class="math inline">\(\hat{\alpha}_b\)</span> and noise/signal <span class="math inline">\(\hat{\sigma}^2\)</span> ratio. <span class="math display">\[
k(i,j; k,l) = \alpha_f\left(\delta_{i,k}  + \delta_{j,l} \hat{\alpha}_b + \delta_{i, k}\delta_{j,l} \hat{\sigma}^2\right)
\]</span> The advantage of this parameterization is it allows us to optimize <span class="math inline">\(\alpha_f\)</span> directly (with a fixed-point equation) and it will be very well determined. This leaves us with two free parameters, that we can explore on the grid. It is in these parameters that we expect the remaining underdetermindness of the model. We expect <span class="math inline">\(\alpha_f\)</span> to be well determined because the negative log likelihood is now <span class="math display">\[
\frac{|\mathbf{y}|}{2}\log\alpha_f + \frac{1}{2}\log  \left|\hat{\mathbf{K}}\right| + \frac{1}{2\alpha_f}\mathbf{y}^\top \hat{\mathbf{K}}^{-1} \mathbf{y},
\]</span> where <span class="math inline">\(|\mathbf{y}|\)</span> is the length of <span class="math inline">\(\mathbf{y}\)</span> (i.e. the number of reviews) and <span class="math inline">\(\hat{\mathbf{K}}=\alpha_f^{-1}\mathbf{K}\)</span> is the scale normalized covariance. This negative log likelihood is easily minimized to recover <span class="math display">\[
\alpha_f = \frac{1}{|\mathbf{y}|} \mathbf{y}^\top \hat{\mathbf{K}}^{-1} \mathbf{y}.
\]</span> A Bayesian analysis of this parameter is possible with gamma priors, but it would merely show that this parameter is extremely well determined (the degrees of freedom parameter of the associated Student-<span class="math inline">\(t\)</span> marginal likelihood scales will the number of reviews, which will be around <span class="math inline">\(|\mathbf{y}| \approx 6,000\)</span> in our case.</p>
<p>So, we propose to proceed as follows. Set the mean from the reviews (<span class="math inline">\(\mu\)</span>) and then choose a two-dimensional grid of parameters for reviewer offset and diversity. For each parameter choice, optimize to find <span class="math inline">\(\alpha_f\)</span> and then evaluate the liklihood. Worst case this will require us inverting <span class="math inline">\(\hat{\mathbf{K}}\)</span>, but if the reviewer paper groups are disconnected, it can be done a lot quicker. Next stage is to load in the reviews for analysis.</p>
<h2 id="fitting-the-model">Fitting the Model</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/reviewer-calibration-fit-model.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/reviewer-calibration-fit-model.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils <span class="im">as</span> cu</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse.csgraph <span class="im">import</span> connected_components</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> solve_triangular </span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>date <span class="op">=</span> <span class="st">&#39;2014-09-06&#39;</span></span></code></pre></div>
<h2 id="loading-in-the-data">Loading in the Data</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> date <span class="op">+</span> <span class="st">&#39;_reviews.xls&#39;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>reviews <span class="op">=</span> cu.CMT_Reviews_read(filename<span class="op">=</span>filename)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>papers <span class="op">=</span> <span class="bu">list</span>(<span class="bu">sorted</span>(<span class="bu">set</span>(reviews.reviews.index), key<span class="op">=</span><span class="bu">int</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>reviews.reviews <span class="op">=</span> reviews.reviews.loc[papers]</span></code></pre></div>
<p>The maximum likelihood solution for <span class="math inline">\(\mu\)</span> is simply the mean quality of the papers, this is easily computed.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> reviews.reviews.Quality.mean()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Mean value, mu = &quot;</span>, mu)</span></code></pre></div>
<h2 id="data-preparation">Data Preparation</h2>
<p>We take the reviews, which are indexed by the paper number, and create a new data frame, that indexes by paper id and email combined. From these reviews we tokenize the <code>PaperID</code> and the <code>Email</code> to extract two matrices that can be used in creation of covariance matrices. We also create a target vector which is the mean centred vector of scores.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> reviews.reviews.reset_index()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>r.rename(columns<span class="op">=</span>{<span class="st">&#39;ID&#39;</span>:<span class="st">&#39;PaperID&#39;</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>r.index <span class="op">=</span> r.PaperID <span class="op">+</span> <span class="st">&#39;_&#39;</span> <span class="op">+</span> r.Email</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> pd.get_dummies(r.PaperID)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> X1[<span class="bu">sorted</span>(X1.columns, key<span class="op">=</span><span class="bu">int</span>)]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> pd.get_dummies(r.Email)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> X2[<span class="bu">sorted</span>(X2.columns, key<span class="op">=</span><span class="bu">str</span>.lower)]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> reviews.reviews.Quality <span class="op">-</span> mu</span></code></pre></div>
<h3 id="constructing-the-model-in-gpy">Constructing the Model in GPy</h3>
<p>Having reduced the model to two parameters, I was hopeful I could set parameters broadly by hand. My initial expectation was that <code>alpha_b</code> and <code>sigma2</code> would both be less than 1, but some playing with parameters showed this wasn’t the case. Rather than waste further time, I decided to use our <a href="https://github.com/SheffieldML/GPy"><code>GPy</code> Software</a> (see below) to find a maximum likelihood solution for the parameters.</p>
<p>Model construction firstly involves constructing covariance functions for the model and concatenating <code>X1</code> and <code>X2</code> to a new input matrix <code>X</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> X1.join(X2)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>kern1 <span class="op">=</span> GPy.kern.Linear(input_dim<span class="op">=</span><span class="bu">len</span>(X1.columns), active_dims<span class="op">=</span>np.arange(<span class="bu">len</span>(X1.columns)))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>kern1.name <span class="op">=</span> <span class="st">&#39;K_f&#39;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>kern2 <span class="op">=</span> GPy.kern.Linear(input_dim<span class="op">=</span><span class="bu">len</span>(X2.columns), active_dims<span class="op">=</span>np.arange(<span class="bu">len</span>(X1.columns), <span class="bu">len</span>(X.columns)))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>kern2.name <span class="op">=</span> <span class="st">&#39;K_b&#39;</span></span></code></pre></div>
<p>Next, the covariance function is used to create a Gaussian process regression model with <code>X</code> as input and <code>y</code> as target. The covariance function is given by <span class="math inline">\(\mathbf{K}_f + \mathbf{K}_b\)</span>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPy.models.GPRegression(X, y.to_numpy()[:, np.newaxis], kern1<span class="op">+</span>kern2)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>model.optimize()</span></code></pre></div>
<p>Now we can check the parameters of the result.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model.log_likelihood())</span></code></pre></div>
<pre><code>    Name : GP regression
    Objective : 10071.679092815619
    Number of Parameters : 3
    Number of Optimization Parameters : 3
    Updates : True
    Parameters:
      GP_regression.           |               value  |  constraints  |  priors
      sum.K_f.variances        |  1.2782303448777643  |      +ve      |        
      sum.K_b.variances        |  0.2400098787580176  |      +ve      |        
      Gaussian_noise.variance  |  1.2683656892796749  |      +ve      |        
    -10071.679092815619</code></pre>
<h3 id="construct-the-model-without-gpy">Construct the Model Without GPy</h3>
<p>The answer from the GPy solution is introduced here, alongside the code where the covariance matrices are explicitly created (above they are created using GPy’s high level code for kernel matrices, which may be less clear on the details).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set parameter values to ML solutions given by GPy.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>alpha_f <span class="op">=</span> model.<span class="bu">sum</span>.K_f.variances</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>alpha_b <span class="op">=</span> model.<span class="bu">sum</span>.K_b.variances<span class="op">/</span>alpha_f</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>sigma2 <span class="op">=</span> model.Gaussian_noise.variance<span class="op">/</span>alpha_f</span></code></pre></div>
<p>Now we create the covariance functions based on the tokenized paper IDs and emails.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>K_f <span class="op">=</span> np.dot(X1, X1.T)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>K_b <span class="op">=</span> alpha_b<span class="op">*</span>np.dot(X2, X2.T)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> K_f <span class="op">+</span> K_b <span class="op">+</span> sigma2<span class="op">*</span>np.eye(X2.shape[<span class="dv">0</span>])</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Kinv, L, Li, logdet <span class="op">=</span> GPy.util.linalg.pdinv(K) <span class="co"># since we have GPy loaded in use their positive definite inverse.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> reviews.reviews.Quality <span class="op">-</span> mu</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> np.dot(Kinv, y)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>yTKinvy <span class="op">=</span> np.dot(y, alpha)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>alpha_f <span class="op">=</span> yTKinvy<span class="op">/</span><span class="bu">len</span>(y)</span></code></pre></div>
<p>Since we have removed the data mean, the log likelihood we are interested in is the likelihood of a multivariate Gaussian with covariance <span class="math inline">\(\mathbf{K}\)</span> and mean zero. This is computed below.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ll <span class="op">=</span> <span class="fl">0.5</span><span class="op">*</span><span class="bu">len</span>(y)<span class="op">*</span>np.log(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>alpha_f) <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>logdet <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>yTKinvy<span class="op">/</span>alpha_f </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;negative log likelihood: &quot;</span>, ll)</span></code></pre></div>
<h3 id="review-quality-prediction">Review Quality Prediction</h3>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/review-quality-prediction.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/review-quality-prediction.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Now we wish to predict the bias corrected scores for the papers. That involves considering a variable <span class="math inline">\(s_{i,j} = f_i + e_{i,j}\)</span> which is the score with the bias removed. That variable has a covariance matrix, <span class="math inline">\(\mathbf{K}_s=\mathbf{K}_f + \sigma^2 \mathbf{I}\)</span> and a cross covariance between <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{s}\)</span> is also given by <span class="math inline">\(\mathbf{K}_s\)</span>. This means we can compute the posterior distribution of the scores as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute mean and covariance of quality scores</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>K_s <span class="op">=</span> K_f <span class="op">+</span> np.eye(K_f.shape[<span class="dv">0</span>])<span class="op">*</span>sigma2</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(np.dot(K_s, alpha) <span class="op">+</span> mu, index<span class="op">=</span>X1.index)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>covs <span class="op">=</span> alpha_f<span class="op">*</span>(K_s <span class="op">-</span> np.dot(K_s, np.dot(Kinv, K_s)))</span></code></pre></div>
<h3 id="monte-carlo-simulations-for-probability-of-acceptance">Monte Carlo Simulations for Probability of Acceptance</h3>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/paper-acceptance-monte-carlo.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/paper-acceptance-monte-carlo.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>We can now sample from this posterior distribution of bias-adjusted scores jointly, to get a set of scores for all papers. For this set of scores, we can perform a ranking and accept the top 400 papers. This gives us a sampled conference. If we do that 1,000 times then we can see how many times each paper was accepted to get a probability of acceptance.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>number_accepts <span class="op">=</span> <span class="dv">420</span> <span class="co"># 440 because of the 10% replication</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># place this in a separate box, because sampling can take a while.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>score <span class="op">=</span> np.random.multivariate_normal(mean<span class="op">=</span>s, cov<span class="op">=</span>covs, size<span class="op">=</span>samples).T</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Use X1 which maps papers to paper/reviewer pairings to get the average score for each paper.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>paper_score <span class="op">=</span> pd.DataFrame(np.dot(np.diag(<span class="fl">1.</span><span class="op">/</span>X1.<span class="bu">sum</span>(<span class="dv">0</span>)), np.dot(X1.T, score)), index<span class="op">=</span>X1.columns)</span></code></pre></div>
<p>Now we can compute the probability of acceptance for each of the sampled rankings.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>prob_accept <span class="op">=</span> ((paper_score<span class="op">&gt;</span>paper_score.quantile(<span class="dv">1</span><span class="op">-</span>(<span class="bu">float</span>(number_accepts)<span class="op">/</span>paper_score.shape[<span class="dv">0</span>]))).<span class="bu">sum</span>(<span class="dv">1</span>)<span class="op">/</span><span class="dv">1000</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>prob_accept.name <span class="op">=</span> <span class="st">&#39;AcceptProbability&#39;</span></span></code></pre></div>
<p>Now we have the probability of accepts, we can decide on the boundaries of the grey area. These are set in <code>lower</code> and <code>upper</code>. The grey area is those papers that will be debated most heavily during the teleconferences between program chairs and area chairs.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>lower<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>upper<span class="op">=</span><span class="fl">0.9</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>grey_area <span class="op">=</span> ((prob_accept<span class="op">&gt;</span>lower) <span class="op">&amp;</span> (prob_accept<span class="op">&lt;</span>upper))</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Number of papers in grey area:&#39;</span>, grey_area.<span class="bu">sum</span>())</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils.plot <span class="im">as</span> plot</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Expected Papers Accepted:&#39;</span>, prob_accept.<span class="bu">sum</span>())</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> prob_accept.hist(bins<span class="op">=</span><span class="dv">40</span>, ax<span class="op">=</span>ax)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>ma.write_figure(directory<span class="op">=</span><span class="st">&quot;./neurips&quot;</span>, filename<span class="op">=</span><span class="st">&quot;probability-of-accept.svg&quot;</span>)</span></code></pre></div>
<div class="figure">
<div id="probability-of-accept-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/probability-of-accept.svg" width="70%" style=" ">
</object>
</div>
<div id="probability-of-accept-magnify" class="magnify" onclick="magnifyFigure(&#39;probability-of-accept&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="probability-of-accept-caption" class="caption-frame">
<p>Figure: Histogram of the probability of accept as estimated by the Monte Carlo simulation across all papers submitted to NeurIPS 2014.</p>
</div>
</div>
<h2 id="some-sanity-checking-plots">Some Sanity Checking Plots</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/calibration-sanity-checks.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/calibration-sanity-checks.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Here is the histogram of the reviewer scores after calibration.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>s.hist(bins<span class="op">=</span><span class="dv">100</span>, ax<span class="op">=</span>ax)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> ax.set_title(<span class="st">&#39;Calibrated Reviewer Scores&#39;</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>ma.write_figure(directory<span class="op">=</span><span class="st">&quot;./neurips&quot;</span>, filename<span class="op">=</span><span class="st">&quot;calibrated-reviewer-scores.svg&quot;</span>)</span></code></pre></div>
<div class="figure">
<div id="calibrated-reviewer-scores-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/calibrated-reviewer-scores.svg" width="70%" style=" ">
</object>
</div>
<div id="calibrated-reviewer-scores-magnify" class="magnify" onclick="magnifyFigure(&#39;calibrated-reviewer-scores&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="calibrated-reviewer-scores-caption" class="caption-frame">
<p>Figure: Histogram of updated reviewer scores after the calibration process is applied.</p>
</div>
</div>
<h3 id="adjustments-to-reviewer-scores">Adjustments to Reviewer Scores</h3>
<p>We can also compute the posterior distribution for the adjustments to the reviewer scores.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute mean and covariance of review biases</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> pd.Series(np.dot(K_b, alpha), index<span class="op">=</span>X2.index)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>covb <span class="op">=</span> alpha_f<span class="op">*</span>(K_b <span class="op">-</span> np.dot(K_b, np.dot(Kinv, K_b)))</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>reviewer_bias <span class="op">=</span> pd.Series(np.dot(np.diag(<span class="fl">1.</span><span class="op">/</span>X2.<span class="bu">sum</span>(<span class="dv">0</span>)), np.dot(X2.T, b)), index<span class="op">=</span>X2.columns, name<span class="op">=</span><span class="st">&#39;ReviewerBiasMean&#39;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>reviewer_bias_std <span class="op">=</span> pd.Series(np.dot(np.diag(<span class="fl">1.</span><span class="op">/</span>X2.<span class="bu">sum</span>(<span class="dv">0</span>)), np.dot(X2.T, np.sqrt(np.diag(covb)))), index<span class="op">=</span>X2.columns, name<span class="op">=</span><span class="st">&#39;ReviewerBiasStd&#39;</span>)</span></code></pre></div>
<p>Here is a histogram of the mean adjustment for the reviewers.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>reviewer_bias.hist(bins<span class="op">=</span><span class="dv">100</span>, ax<span class="op">=</span>ax)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> ax.set_title(<span class="st">&#39;Reviewer Calibration Adjustments Histogram&#39;</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>ma.write_figure(directory<span class="op">=</span><span class="st">&quot;./neurips&quot;</span>, filename<span class="op">=</span><span class="st">&quot;reviewer-calibration-adjustments.svg&quot;</span>)</span></code></pre></div>
<div class="figure">
<div id="reviewer-calibration-adjustments-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/reviewer-calibration-adjustments.svg" width="70%" style=" ">
</object>
</div>
<div id="reviewer-calibration-adjustments-magnify" class="magnify" onclick="magnifyFigure(&#39;reviewer-calibration-adjustments&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="reviewer-calibration-adjustments-caption" class="caption-frame">
<p>Figure: Histogram of individual offsets associated with the reviewers as estimated by the model.</p>
</div>
</div>
<p>Export a version of the bias scores for use in CMT.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>bias_export <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>{<span class="st">&#39;Quality Score - Does the paper deserves to be published?&#39;</span>:reviewer_bias, </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">&#39;Impact Score - Independently of the Quality Score above, this is your opportunity to identify papers that are very different, original, or otherwise potentially impactful for the NIPS community.&#39;</span>:pd.Series(np.zeros(<span class="bu">len</span>(reviewer_bias)), index<span class="op">=</span>reviewer_bias.index),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;Confidence&#39;</span>:pd.Series(np.zeros(<span class="bu">len</span>(reviewer_bias)), index<span class="op">=</span>reviewer_bias.index)})</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> bias_export.columns.tolist()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [cols[<span class="dv">2</span>], cols[<span class="dv">1</span>], cols[<span class="dv">0</span>]]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>bias_export <span class="op">=</span> bias_export[cols]</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">#bias_export.to_csv(os.path.join(cu.cmt_data_directory, &#39;reviewer_bias.csv&#39;), sep=&#39;\t&#39;, header=True, index_label=&#39;Reviewer Email&#39;)</span></span></code></pre></div>
<h2 id="sanity-check">Sanity Check</h2>
<p>As a sanity check Corinna suggested it makes sense to plot the average raw score for the papers vs the probability of accept, just to ensure nothing weird is going on. To clarify the plot, I’ve actually plotted raw score vs log odds of accept.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>raw_score <span class="op">=</span> pd.Series(np.dot(np.diag(<span class="fl">1.</span><span class="op">/</span>X1.<span class="bu">sum</span>(<span class="dv">0</span>)), np.dot(X1.T, r.Quality)), index<span class="op">=</span>X1.columns)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>prob_accept[prob_accept<span class="op">==</span><span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">10</span><span class="op">*</span>samples)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>prob_accept[prob_accept<span class="op">==</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">-</span><span class="dv">1</span><span class="op">/</span>(<span class="dv">10</span><span class="op">*</span>samples)</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>ax.plot(raw_score, np.log(prob_accept)<span class="op">-</span> np.log(<span class="dv">1</span><span class="op">-</span>prob_accept), <span class="st">&#39;rx&#39;</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&#39;Raw Score vs Log odds of accept&#39;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;raw score&#39;</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> ax.set_ylabel(<span class="st">&#39;log odds of accept&#39;</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>ma.write_figure(directory<span class="op">=</span><span class="st">&quot;./neurips&quot;</span>, filename<span class="op">=</span><span class="st">&quot;raw-score-vs-log-odds.svg&quot;</span>)</span></code></pre></div>
<div class="figure">
<div id="raw-score-vs-log-odds-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/raw-score-vs-log-odds.svg" width="70%" style=" ">
</object>
</div>
<div id="raw-score-vs-log-odds-magnify" class="magnify" onclick="magnifyFigure(&#39;raw-score-vs-log-odds&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="raw-score-vs-log-odds-caption" class="caption-frame">
<p>Figure: Scatter plot of the raw paper score against the log probability of paper acceptance, as estimated by Monte Carlo simulation.</p>
</div>
</div>
<h2 id="calibraton-quality-sanity-checks">Calibraton Quality Sanity Checks</h2>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>s.name <span class="op">=</span> <span class="st">&#39;CalibratedQuality&#39;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> r.join(s)</span></code></pre></div>
<p>We can also look at a scatter plot of the review quality vs the calibrated quality.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>ax.plot(r.Quality, r.CalibratedQuality, <span class="st">&#39;r.&#39;</span>, markersize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>ax.set_xlim([<span class="dv">0</span>, <span class="dv">11</span>])</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;original review score&#39;</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> ax.set_ylabel(<span class="st">&#39;calibrated review score&#39;</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>ma.write_figure(directory<span class="op">=</span><span class="st">&quot;./neurips&quot;</span>, filename<span class="op">=</span><span class="st">&quot;calibrated-review-score-vs-original-score.svg&quot;</span>)</span></code></pre></div>
<div class="figure">
<div id="calibrated-review-vs-original-score-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/calibrated-review-score-vs-original-score.svg" width="70%" style=" ">
</object>
</div>
<div id="calibrated-review-vs-original-score-magnify" class="magnify" onclick="magnifyFigure(&#39;calibrated-review-vs-original-score&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="calibrated-review-vs-original-score-caption" class="caption-frame">
<p>Figure: Scatter plot of the calibrated review scores against the original review scores.</p>
</div>
</div>
<h2 id="correlation-of-duplicate-papers">Correlation of Duplicate Papers</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/calibration-correlation-of-duplicate-papers.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/calibration-correlation-of-duplicate-papers.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>For NeurIPS 2014 we experimented with duplicate papers: we pushed papers through the system twice, exposing them to different subsets of the reviewers. The first thing we’ll look at is the duplicate papers. Firstly, we identify them by matching on title.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> date <span class="op">+</span> <span class="st">&#39;_paper_list.xls&#39;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>papers <span class="op">=</span> cu.CMT_Papers_read(filename<span class="op">=</span>filename)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>duplicate_list <span class="op">=</span> []</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ID, title <span class="kw">in</span> papers.papers.Title.iteritems():</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">int</span>(ID)<span class="op">&gt;</span><span class="dv">1779</span> <span class="kw">and</span> <span class="bu">int</span>(ID) <span class="op">!=</span> <span class="dv">1949</span>:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        pair <span class="op">=</span> <span class="bu">list</span>(papers.papers[papers.papers[<span class="st">&#39;Title&#39;</span>].<span class="bu">str</span>.contains(papers.papers.Title[ID].strip())].index)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        pair.sort(key<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        duplicate_list.append(pair)</span></code></pre></div>
<p>Next, we compute the correlation coefficients for the duplicated papers for the average impact and quality scores.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>quality <span class="op">=</span> []</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>calibrated_quality <span class="op">=</span> []</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>accept <span class="op">=</span> []</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>impact <span class="op">=</span> []</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>confidence <span class="op">=</span> []</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> duplicate_pair <span class="kw">in</span> duplicate_list:</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    quality.append([np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">0</span>]].Quality), np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">1</span>]].Quality)])</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    calibrated_quality.append([np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">0</span>]].CalibratedQuality), np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">1</span>]].CalibratedQuality)])</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    impact.append([np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">0</span>]].Impact), np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">1</span>]].Impact)])</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    confidence.append([np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">0</span>]].Conf), np.mean(r[r.PaperID<span class="op">==</span>duplicate_pair[<span class="dv">1</span>]].Conf)])</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>quality <span class="op">=</span> np.array(quality)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>calibrated_quality <span class="op">=</span> np.array(calibrated_quality)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>impact <span class="op">=</span> np.array(impact)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>confidence <span class="op">=</span> np.array(confidence)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>quality_cor <span class="op">=</span> np.corrcoef(quality.T)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>calibrated_quality_cor <span class="op">=</span> np.corrcoef(calibrated_quality.T)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>impact_cor <span class="op">=</span> np.corrcoef(impact.T)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>confidence_cor <span class="op">=</span> np.corrcoef(confidence.T)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Quality correlation: &quot;</span>, quality_cor)</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Calibrated Quality correlation: &quot;</span>, calibrated_quality_cor)</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Impact correlation: &quot;</span>, impact_cor)</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Confidence correlation: &quot;</span>, confidence_cor)</span></code></pre></div>
<pre><code>    Quality correlation:  0.54403674862622
    Calibrated Quality correlation:  0.5455958618174274
    Impact correlation:  0.26945269236041036
    Confidence correlation:  0.3854251559444674</code></pre>
<h2 id="correlation-plots">Correlation Plots</h2>
<p>To visualize the quality score correlation, we plot the group 1 papers against the group 2 papers. Here we add a small amount of jitter to ensure points to help visualize points that would otherwise fall on the same position.</p>
<div class="figure">
<div id="quality-correlation-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/quality-correlation.svg" width="60%" style=" ">
</object>
</div>
<div id="quality-correlation-magnify" class="magnify" onclick="magnifyFigure(&#39;quality-correlation&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="quality-correlation-caption" class="caption-frame">
<p>Figure: Correlation between reviewer scores across the duplicated committees (scores have jitter added to prevent too many points sitting on top of each other).</p>
</div>
</div>
<p>Similarly for the calibrated quality of the papers.</p>
<div class="figure">
<div id="calibrated-quality-correlation-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/calibrated-quality-correlation.svg" width="60%" style=" ">
</object>
</div>
<div id="calibrated-quality-correlation-magnify" class="magnify" onclick="magnifyFigure(&#39;calibrated-quality-correlation&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="calibrated-quality-correlation-caption" class="caption-frame">
<p>Figure: Correlation between calibrated reviewer scores across the two independent committees.</p>
</div>
</div>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply Laplace smoothing to accept probabilities before incorporating them.</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>revs <span class="op">=</span> r.join((prob_accept<span class="op">+</span><span class="fl">0.0002</span>)<span class="op">/</span><span class="fl">1.001</span>, on<span class="op">=</span><span class="st">&#39;PaperID&#39;</span>).join(reviewer_bias, on<span class="op">=</span><span class="st">&#39;Email&#39;</span>).join(papers.papers[<span class="st">&#39;Number Of Discussions&#39;</span>], on<span class="op">=</span><span class="st">&#39;PaperID&#39;</span>).join(reviewer_bias_std, on<span class="op">=</span><span class="st">&#39;Email&#39;</span>).sort_values(by<span class="op">=</span>[<span class="st">&#39;AcceptProbability&#39;</span>,<span class="st">&#39;PaperID&#39;</span>, <span class="st">&#39;CalibratedQuality&#39;</span>], ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>revs.set_index([<span class="st">&#39;PaperID&#39;</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> len_comments(x):</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(x.Comments)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>revs[<span class="st">&#39;comment_length&#39;</span>]<span class="op">=</span>revs.<span class="bu">apply</span>(len_comments, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Save the computed information to disk</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">#revs.to_csv(os.path.join(cu.cmt_data_directory, date + &#39;_processed_reviews.csv&#39;), encoding=&#39;utf-8&#39;)</span></span></code></pre></div>
<h2 id="conference-simulation">Conference Simulation</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-simulation.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-simulation.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Given the realization that roughly 50% of the score seems to be ‘subjective’ and 50% of the score seems to be ‘objective,’ then we can simulate the conference and see what it does for the accept precision for different probability of accept.</p>
<p>To explore the effect of the subjective scoring on the accept precision we construct a simple simulation that scores hypothetical papers with random values drawn from a Gaussian density. Each paper has an underlying objective score (shared across the hypothetical reviewers), and then alongside it there are Gaussian variables drawn independently at random to represent the subjectivity of the hypothetical reviewers.</p>
<p>Each paper is rated by two independent committees, and the papers are reordered to accept the top <span class="math inline">\(x\)</span>% where <span class="math inline">\(x\)</span> is our chosen accept rate. We can then use sample based estimates for the resulting accept precision.</p>
<p>In these experiments the scores are taken to be 50% subjective and 50% objective, in line with the results we see from the NeurIPS 2014 calibration model. We vary the number of reviewers in the simulation to see the effect of increasing reviewers on the accept precision.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<p>We repeat the experiment <code>samples</code> number of times, here we’ve set this to be 100000. The subjectivity portion gives how much of the scores for each paper is subjective.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>num_papers <span class="op">=</span> <span class="dv">100000</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>subjectivity_portion <span class="op">=</span> <span class="fl">0.5</span></span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>accept_rates <span class="op">=</span> [<span class="fl">0.05</span>, <span class="fl">0.1</span>, <span class="fl">0.15</span>, <span class="fl">0.2</span>, <span class="fl">0.25</span>, </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                      <span class="fl">0.3</span>, <span class="fl">0.35</span>, <span class="fl">0.4</span>, <span class="fl">0.45</span>, <span class="fl">0.5</span>, </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                      <span class="fl">0.55</span>, <span class="fl">0.6</span>, <span class="fl">0.65</span>, <span class="fl">0.7</span>, <span class="fl">0.75</span>, </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                      <span class="fl">0.8</span>, <span class="fl">0.85</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>, <span class="fl">1.0</span>]</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>all_accepts <span class="op">=</span> []</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num_reviewers <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>):</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    consistent_accepts <span class="op">=</span> []</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> accept_rate <span class="kw">in</span> accept_rates:</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        objective <span class="op">=</span> (<span class="dv">1</span><span class="op">-</span>subjectivity_portion)<span class="op">*</span>np.random.randn(num_papers) </span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        subjective_0 <span class="op">=</span> subjectivity_portion<span class="op">*</span>np.random.randn(num_papers, num_reviewers).mean(<span class="dv">1</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        subjective_1 <span class="op">=</span> subjectivity_portion<span class="op">*</span>np.random.randn(num_papers, num_reviewers).mean(<span class="dv">1</span>)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>        score_0 <span class="op">=</span> objective <span class="op">+</span> subjective_0    </span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        score_1 <span class="op">=</span> objective <span class="op">+</span> subjective_1</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        accept_0 <span class="op">=</span> score_0.argsort()[:<span class="bu">int</span>(num_papers<span class="op">*</span>accept_rate)]</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        accept_1 <span class="op">=</span> score_1.argsort()[:<span class="bu">int</span>(num_papers<span class="op">*</span>accept_rate)]</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>        consistent_accept <span class="op">=</span> <span class="bu">len</span>(<span class="bu">set</span>(accept_0).intersection(<span class="bu">set</span>(accept_1)))</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        consistent_accepts.append(consistent_accept<span class="op">/</span>(num_papers<span class="op">*</span>accept_rate))</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&#39;Percentage consistently accepted: </span><span class="sc">{prop}</span><span class="st">&#39;</span>.<span class="bu">format</span>(prop<span class="op">=</span>consistent_accept<span class="op">/</span>(num_papers<span class="op">*</span>accept_rate)))</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    all_accepts.append(consistent_accepts)</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>all_accepts <span class="op">=</span> np.array(all_accepts)</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>consistent_accepts <span class="op">=</span> np.array(consistent_accepts)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>accept_rate <span class="op">=</span> np.array(accept_rate)</span></code></pre></div>
<div class="figure">
<div id="accept-precision-vs-accept-rate-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/accept-precision-vs-accept-rate.svg" width="50%" style=" ">
</object>
</div>
<div id="accept-precision-vs-accept-rate-magnify" class="magnify" onclick="magnifyFigure(&#39;accept-precision-vs-accept-rate&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="accept-precision-vs-accept-rate-caption" class="caption-frame">
<p>Figure: Plot of the accept rate vs the accept precision for the conference for 50% subjectivity and different numbers of reviewers. The grey line gives the NeurIPS accept rate for 2014 of 23%.</p>
</div>
</div>
<p>In Figure  we see the change in accept precision as we vary accept rate and number of reviewers for a conference where reviewers are 50% subjective.</p>
<div class="figure">
<div id="gain-in-consistency-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/gain-in-consistency.svg" width="50%" style=" ">
</object>
</div>
<div id="gain-in-consistency-magnify" class="magnify" onclick="magnifyFigure(&#39;gain-in-consistency&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="gain-in-consistency-caption" class="caption-frame">
<p>Figure: Plot of the accept rate vs gain in consistency over a random conference for 50% subjectivity.</p>
</div>
</div>
<p>Figure  shows the accept rate against the gain in accept precision we have over the random committee.</p>
<h2 id="where-do-rejected-papers-go">Where do Rejected Papers Go?</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/where-do-the-rejected-papers-go.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/where-do-the-rejected-papers-go.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>One facet that we can explore is what the final fate of papers that are rejected by the conference is.</p>
<p>Of the 1,678 papers submitted to NeurIPS 2014, only 414 were presented at the final conference. Here we trace the fate of the rejected papers, we searched Semantic Scholar for evidence of all 1,264 rejected papers. We looked for papers with similar titles and where the NeurIPS submission’s contact author was also in the author list. We were able to track down 680 papers.</p>
<p>This code analyzes those 680 papers extracting their final publication venue using the Semantic Scholar API.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install cmtutils</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils.nipsy <span class="im">as</span> nipsy</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yaml</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(os.path.join(nipsy.review_store, nipsy.outlet_name_mapping), <span class="st">&#39;r&#39;</span>) <span class="im">as</span> f:</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    mapping <span class="op">=</span> yaml.load(f, Loader<span class="op">=</span>yaml.FullLoader)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>date <span class="op">=</span> <span class="st">&quot;2021-06-11&quot;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>citations <span class="op">=</span> nipsy.load_citation_counts(date<span class="op">=</span>date)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>decisions <span class="op">=</span> nipsy.load_decisions()</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>nipsy.augment_decisions(decisions)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>joindf <span class="op">=</span> nipsy.join_decisions_citations(decisions, citations)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>joindf[<span class="st">&#39;short_venue&#39;</span>] <span class="op">=</span> joindf.venue.replace(mapping)</span></code></pre></div>
<div class="figure">
<div id="where-do-neurips-papers-go-figure" class="figure-frame">
<iframe src="https://inverseprobability.com/talks/./slides/diagrams//neurips/where-do-neurips-papers-go.html" width="600" height="450" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="where-do-neurips-papers-go-magnify" class="magnify" onclick="magnifyFigure(&#39;where-do-neurips-papers-go&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="where-do-neurips-papers-go-caption" class="caption-frame">
<p>Figure: Sankey diagram showing the flow of NeurIPS papers through the system from submission to eventual publication.</p>
</div>
</div>
<p>Of the 680 papers 177 were only found on arXiv, 76 were found as PDFs online without a publication venue and 427 were published in other venues. The outlets that received ten or more papers from this group were AAAI (72 papers), AISTATS (57 papers), ICML (33 papers), CVPR (17 papers), Later NeurIPS (15 papers), JMLR (14 papers), IJCAI (14 papers), ICLR (13 papers), UAI (11 papers). Opinion about quality of these different outlets will vary from individual, but from our perspective all of these outlets are `top-tier’ for machine learning and related areas. Other papers appeared at less prestigious outlets, and citation scores were also recored for papers that remained available only on ArXiv. Note that there is likely a bias towards outlets that have a submission deadline shortly after NeurIPS decisions are public, e.g. submission deadline for AAAI 2015 was six days after NeurIPS decisions were sent to authors. AISTATS has a submission deadline one month after.</p>
<p>A Sankey diagram showing where papers submitted to the conference ended up is shown below.</p>
<div class="figure">
<div id="where-do-neurips-papers-go-figure" class="figure-frame">
<iframe src="https://inverseprobability.com/talks/./slides/diagrams//neurips/where-do-neurips-papers-go.html" width="600" height="450" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="where-do-neurips-papers-go-magnify" class="magnify" onclick="magnifyFigure(&#39;where-do-neurips-papers-go&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="where-do-neurips-papers-go-caption" class="caption-frame">
<p>Figure: Sankey diagram showing the flow of NeurIPS papers through the system from submission to eventual publication.</p>
</div>
</div>
<!-- 




## Effect of Late Reviews

<div style="text-align:right"><span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/effect-of-late-reviewers.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/effect-of-late-reviewers.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></div>



This notebook analyzes the reduction in reviewer confidence between
reviewers that submit their reviews early and those that arrive late.
The reviews are first loaded in from files Corinna and Neil saved and
stored in a pickle. The function for doing that is
`nips.load_review_history`.



```{.python}
import cmtutils as cu
import cmtutils.nipsy as nipsy 
import cmtutils.plot as plot

import os
import pandas as pd
import numpy as np
```

```{.python}
reviews = nipsy.load_review_history()
```

## Review Submission Times





All reviews are now in `pandas` data frame called reviews, they are ready
for processing. First of all, let\'s take a look at when the reviews
were submitted. The function `nipsy.reviews_before` gives a snapshot of
the reviews as they stood at a particular date. So we simply create a
data series across the data range of reviews (`nipsy.review_data_range`)
that shows the counts.

```{.python}
review_count = pd.Series(index=nipsy.review_date_range)
for date in nipsy.review_date_range:
    review_count.loc[date] = nipsy.reviews_before(reviews, date).Quality.shape[0]
```





<div class="figure">
<div class="figure-frame" id="review-count-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-count.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="review-count-magnify" onclick="magnifyFigure('review-count')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-count-caption">
Figure: Cumulative count of number of received reviews over time.
</div>
</div>

We worked hard to try and ensure that all papers had three reviews
before the start of the rebuttal. This next plot shows the numbers of
papers that had less than three reviews across the review period. First
let's look at the overall statistics of what the count of reviewers per
paper were. Below we plot mean, maximum, median, and minimum over time.

```{.python}
lastseen = reviews.drop_duplicates(subset='ID').set_index('ID')
lastseen = lastseen['LastSeen']

review_count = pd.DataFrame(index=reviews.ID.unique(), columns=nipsy.review_date_range)
for date in nipsy.review_date_range:
    counts = nipsy.reviews_status(reviews, date, column='Quality').count(level='ID')
    review_count[date] = counts.fillna(0)
review_count.fillna(0, inplace=True)    
review_count = review_count.T
for col in review_count.columns:
    if pd.notnull(lastseen[col]):
        review_count[col][review_count.index>lastseen[col]] = np.NaN
        
review_count = review_count.T
```





<div class="figure">
<div class="figure-frame" id="number-of-reviews-over-time-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/number-of-reviews-over-time.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="number-of-reviews-over-time-magnify" onclick="magnifyFigure('number-of-reviews-over-time')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="number-of-reviews-over-time-caption">
Figure: Plot representing number of reviewers per paper over time showing maximum number of reviewers per paper, minimum, median, and mean. 
</div>
</div>

But perhaps the more important measure is how many papers had less than
3 reviewers over time. In this plot you can see that by the time
rebuttal starts almost all papers have three reviewers.

```{.python}
count = pd.Series(index=nipsy.review_date_range)
for date in nipsy.review_date_range:
    count[date] = (review_count[date]<3).sum()
```





<div class="figure">
<div class="figure-frame" id="paper-short-reviews-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/paper-short-reviews.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="paper-short-reviews-magnify" onclick="magnifyFigure('paper-short-reviews')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="paper-short-reviews-caption">
Figure: Number of papers with less than three reviewers as a function of time.
</div>
</div>

## Review Confidence





Now we will check the confidence of reviews as the come in over time.
We've written a small helper function that looks in a four-day window
around each time point and summarises the associated score (in the first
case, confidence, `Conf`) with its across the four day window and 95%
confidence intervals computed from the standard error of the mean
estimate.






<div class="figure">
<div class="figure-frame" id="review-confidence-time-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-confidence-time.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="review-confidence-time-magnify" onclick="magnifyFigure('review-confidence-time')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-confidence-time-caption">
Figure: Average confidence of reviews as computed across a four-day moving window, plot includes sandard error the mean estimate.
</div>
</div>

It looks like there might be a reduction in confidence as we pass the
review deadline on 21st July, but is the difference in confidence for
the reviews that came in later significant?

We now simplify the question by looking at the average confidence for
reviews that arrived before 21st July (the reviewing deadline) and
reviews that arrived after the 21st July (i.e. those that were chased or
were allocated late) but before the rebuttal period started (4th
August). Below we select these two groups and estimate the estimate of
the mean confidence with (again with error bars).




<div class="figure">
<div class="figure-frame" id="review-confidence-early-late-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-confidence-early-late.svg" width="50%" style=" "></object>
</div>
<div class="magnify" id="review-confidence-early-late-magnify" onclick="magnifyFigure('review-confidence-early-late')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-confidence-early-late-caption">
Figure: Average confindence for reviews that arrived before 21st July (the reviewing deadline) and reviews that arrived after. Histogram shows mean values and confidence intervals. A $t$-test shows the difference to be significant with a $p$-value of 0.048%, although the magnitude of the difference is small (about 0.1).
</div>
</div>

So, it looks like there is a small but significant difference between the
average confidence of the submitted reviews before and after the
deadline, the statistical significance is confirmed with a $t$-test with
a $p$-value at 0.048%. The magnitude of the difference is small (about
0.1) but may indicate a tendency for later reviewers to be a little more
rushed.

### Quality Score





This begs the question, is there an effect on the other scores of their
reviews which cover 'quality' and 'impact'. Quality of papers is
scored on a 10-point scale with a recommendation of 6 being accept and
We can form a similar plots for quality as shown in Figures \ref{review-quality-time} and \ref{review-quality-early-late}.




<div class="figure">
<div class="figure-frame" id="review-quality-time-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-quality-time.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="review-quality-time-magnify" onclick="magnifyFigure('review-quality-time')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-quality-time-caption">
Figure: Plot of average review quality score as a function of time using a four day moving window. Standard error is also shown in the plot.
</div>
</div>



<div class="figure">
<div class="figure-frame" id="review-quality-early-late-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-quality-early-late.svg" width="50%" style=" "></object>
</div>
<div class="magnify" id="review-quality-early-late-magnify" onclick="magnifyFigure('review-quality-early-late')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-quality-early-late-caption">
Figure: Bar plot of average quality scores for on-time reviews and late reviews, standard errors shown. Under a $t$-test the difference in values is statistically significant with a $p$-value of 0.007%.
</div>
</div>

There is another statistically significant difference between perceived
quality scores after the reviewing deadline than before. On average
reviewers tend to be more generous in their quality perceptions when the
review is late. The $p$-value is computed as 0.007%. We can also check
if there is a similar on the impact score. The impact score was
introduced by Ghahramani and Welling to get reviewers not
just to think about the technical side of the paper, but whether it is
driving the field forward. The score is binary, with 1 being for a paper
that is unlikely to have high impact and 2 being for a paper that is
likely to have a high impact.




<div class="figure">
<div class="figure-frame" id="review-impact-time-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-impact-time.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="review-impact-time-magnify" onclick="magnifyFigure('review-impact-time')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-impact-time-caption">
Figure: Average impact score for papers over time, again using a moving average with a window of four days and with standard error of the mean computation shown.
</div>
</div>



<div class="figure">
<div class="figure-frame" id="review-impact-early-late-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-impact-early-late.svg" width="50%" style=" "></object>
</div>
<div class="magnify" id="review-impact-early-late-magnify" onclick="magnifyFigure('review-impact-early-late')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-impact-early-late-caption">
Figure: Bar plot showing the average impact score of reviews submitted before the deadline and after the deadline. The difference in means did not prove to be statistically significant under a $t$-test ($p$-value 5.9%).
</div>
</div>

We find the difference is not quite statistically significant for the
impact score ($p$-value of 5.9%), but if anything, there is a trend to
have slightly higher impacts for later reviews (see Figures \ref{review-impact-time} and \ref{review-impact-early-late}).

### Review Length





A final potential indicator of review quality is the length of the
reviews, we can check if there is a difference between the combined
length of the review summary and the main body comments for late and
early reviews (see Figures \ref{review-length-time} and \ref{review-length-early-late}).



<div class="figure">
<div class="figure-frame" id="review-length-time-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-length-time.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="review-length-time-magnify" onclick="magnifyFigure('review-length-time')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-length-time-caption">
Figure: Average length of reviews submitted plotted as a function of time with standard error of the mean computation included.
</div>
</div>



<div class="figure">
<div class="figure-frame" id="review-length-early-late-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/review-length-early-late.svg" width="50%" style=" "></object>
</div>
<div class="magnify" id="review-length-early-late-magnify" onclick="magnifyFigure('review-length-early-late')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="review-length-early-late-caption">
Figure: Bar plot of the average length of reviews submitted before and after the deadline with standard errors included. The difference of around 100 words is statistically significant under a $t$-test ($p$-value 0.55%).
</div>
</div>

Once again we find a small but statistically significant difference,
here, as we might expect late reviews are shorter than those submitted
on time, by about 100 words in a 2,400 word review.

```{.python}
review_quality = pd.DataFrame(index=reviews.ID.unique(), columns=nipsy.review_date_range)
for date in nipsy.review_date_range:
    qual = nipsy.reviews_status(reviews, date, column='Quality')
    review_quality[date] = qual.sum(level='ID')/qual.count(level='ID') # There's a bug where mean doesn't work in Pandas 1.2.4??
```

```{.python}
original_pairs = pd.read_csv(os.path.join(nipsy.review_store, 'Duplicate_PaperID_Pairs.csv'), index_col='original')
duplicate_pairs = pd.read_csv(os.path.join(nipsy.review_store, 'Duplicate_PaperID_Pairs.csv'), index_col='duplicate')
```

Perform an 'inner join' on duplicate papers and their originals with
their reviews, and set the index of the duplicated papers to match the
original. This gives us data frames with matching indices containing
scores over time of the duplicate and original papers.

```{.python}
duplicate_reviews = duplicate_pairs.join(review_quality, how="inner").set_index('original')
original_reviews = original_pairs.join(review_quality, how="inner")
del original_reviews["duplicate"]
```

```{.python}
corr_series = duplicate_reviews.corrwith(original_reviews)
corr_series.index = pd.to_datetime(corr_series.index)
```



```{.python}
bootstrap_corr_df = pd.DataFrame(index=corr_series.index)
for i in range(1000):
    ind = bootstrap_index(original_reviews)
    b_corr_series = duplicate_reviews.loc[ind].corrwith(original_reviews.loc[ind])
    b_corr_series.index = pd.to_datetime(b_corr_series.index)
    bootstrap_corr_df[i] = b_corr_series
```

```{.python}
import datetime as dt
```



<div class="figure">
<div class="figure-frame" id="correlation-duplicate-reviews-bootstrap-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/correlation-duplicate-reviews-bootstrap.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="correlation-duplicate-reviews-bootstrap-magnify" onclick="magnifyFigure('correlation-duplicate-reviews-bootstrap')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="correlation-duplicate-reviews-bootstrap-caption">
Figure: Average correlation of duplicate papers over time. To give an estimate of the uncertainty the correlation is computed with bootstrap samples. Here to allow comparison between the trend lines similar, the bootstrap samples are set so they converge on the same point on the right of the graph.
</div>
</div>




<div class="figure">
<div class="figure-frame" id="correlation-duplicate-reviews-figure">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/correlation-duplicate-reviews.svg" width="70%" style=" "></object>
</div>
<div class="magnify" id="correlation-duplicate-reviews-magnify" onclick="magnifyFigure('correlation-duplicate-reviews')"><img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex"></div>
<div class="caption-frame" id="correlation-duplicate-reviews-caption">
Figure: Average correlation of duplicate papers over time.
</div>
</div>

We need to do a bit more analysis on the estimation of the correlation
for the earlier submissions, but from what we see above, it looks like
the correlation is being damaged by late reviews, and we never quite
recover the consistency of reviews we had at the submission deadline
even after the discussion phase is over.

## Late Reviewers Summary





In summary we find that late reviews are on average less confident and
shorter, but rate papers as higher quality and perhaps as higher impact.
Each of the effects is small (around 5%) but overall a picture emerges
of a different category of review from those that delay their assessment.



 -->
<!--  -->
<!--  -->
<h2 id="impact-of-papers-seven-years-on">Impact of Papers Seven Years On</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/impact-of-papers-seven-years-on.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/impact-of-papers-seven-years-on.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Now we look at the actual impact of the papers published using the Semantic Scholar data base for tracking citations.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils <span class="im">as</span> cu</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils.nipsy <span class="im">as</span> nipsy</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmtutils.plot <span class="im">as</span> plot</span></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>papers <span class="op">=</span> cu.Papers()</span></code></pre></div>
<p><a href="https://proceedings.neurips.cc/paper/2014" class="uri">https://proceedings.neurips.cc/paper/2014</a></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>UPDATE_IMPACTS <span class="op">=</span> <span class="va">False</span> <span class="co"># Set to True to download impacts from Semantic Scholar</span></span></code></pre></div>
<p>The impact of the different papers is downloaded from Semantic scholar using their REST API. This can take some time, and they also throttle the calls. At the moment the code below deosn’t handle the throttling correctly. However, you it will load the cached version of of citations scores from the given date.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> UPDATE_IMPACTS:</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    date<span class="op">=</span>datetime.today().strftime(<span class="st">&#39;%Y-%m-</span><span class="sc">%d</span><span class="st">&#39;</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    date <span class="op">=</span> <span class="st">&quot;2021-06-11&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Rerun to download impacts from Semantic Scholar</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> UPDATE_IMPACTS:</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    semantic_ids <span class="op">=</span> nipsy.load_semantic_ids()</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    citations_dict <span class="op">=</span> citations.to_dict(orient<span class="op">=</span><span class="st">&#39;index&#39;</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Need to be a bit cleverer here. Semantic scholar will throttle this call.</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    sscholar <span class="op">=</span> nipsy.download_citation_counts(citations_dict<span class="op">=</span>citations_dict, semantic_ids<span class="op">=</span>semantic_ids)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    citations <span class="op">=</span> pd.DataFrame.from_dict(citations_dict, orient<span class="op">=</span><span class="st">&quot;index&quot;</span>) </span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    citations.to_pickle(date <span class="op">+</span> <span class="st">&#39;-semantic-scholar-info.pickle&#39;</span>)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>: </span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    citations <span class="op">=</span> nipsy.load_citation_counts(date<span class="op">=</span>date)</span></code></pre></div>
<p>The final decision sheet provides information about what happened to all of the papers.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>decisions <span class="op">=</span> nipsy.load_decisions()</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>nipsy.augment_decisions(decisions)</span></code></pre></div>
<p>This is joined with the citation information to provide our main ability to understand the impact of these papers.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>joindf <span class="op">=</span> nipsy.join_decisions_citations(decisions, citations)</span></code></pre></div>
<h3 id="correlation-of-quality-scores-and-citation">Correlation of Quality Scores and Citation</h3>
<p>Our first study will be to check the correlation between quality scores of papers and how many times that the papers have been cited in practice. In the plot below, rejected papers are given as crosses, accepted papers are given as dots. We include all papers, whether published in a venue or just available through ArXiv or other preprint servers. We show the published/non-published quality scores and <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> for all papers in the plot below. In the plot we are showing each point corrupted by some Laplacian noise and also removing axes. The idea is to give a sense of the distribution rather than reveal the score of a particular paper.</p>
<div class="figure">
<div id="citations-vs-average-calibrated-quality-all-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/citations-vs-average-calibrated-quality-all.svg" width="70%" style=" ">
</object>
</div>
<div id="citations-vs-average-calibrated-quality-all-magnify" class="magnify" onclick="magnifyFigure(&#39;citations-vs-average-calibrated-quality-all&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="citations-vs-average-calibrated-quality-all-caption" class="caption-frame">
<p>Figure: Scatter plot of <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> against the average calibrated quality score for all papers. To prevent reidentification of individual papers quality scores and citation count, each point is corrupted by differentially private noise in the plot (correlation is computed before adding differentially private noise).</p>
</div>
</div>
<p>The correlation seems strong, but of course, we are looking at papers which were accepted and rejected by the conference. This is dangerous, as it is quite likely that presentation at the conference may provide some form of lift to the papers’ numbers of citations. So, the right thing to do is to look at the groups separately.</p>
<p>Looking at the accepted papers only shows a very different picture. There is very little correlation between accepted papers’ quality scores and the number of citations they receive.</p>
<div class="figure">
<div id="citations-vs-average-calibrated-quality-accept-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/citations-vs-average-calibrated-quality-accept.svg" width="70%" style=" ">
</object>
</div>
<div id="citations-vs-average-calibrated-quality-accept-magnify" class="magnify" onclick="magnifyFigure(&#39;citations-vs-average-calibrated-quality-accept&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="citations-vs-average-calibrated-quality-accept-caption" class="caption-frame">
<p>Figure: Scatter plot of <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> against the average calibrated quality score for accepted papers. To prevent reidentification of individual papers quality scores and citation count, each point is corrupted by differentially private noise in the plot (correlation is computed before adding differentially private noise).</p>
</div>
</div>
<p>Conversely, looking at rejected papers only, we do see a slight trend, with higher scoring papers achieving more citations on average. This, combined with the lower average number of citations in the rejected paper group, alongside their lower average scores, explains the correlation we originally observed.</p>
<div class="figure">
<div id="citations-vs-average-calibrated-quality-reject-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/citations-vs-average-calibrated-quality-reject.svg" width="70%" style=" ">
</object>
</div>
<div id="citations-vs-average-calibrated-quality-reject-magnify" class="magnify" onclick="magnifyFigure(&#39;citations-vs-average-calibrated-quality-reject&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="citations-vs-average-calibrated-quality-reject-caption" class="caption-frame">
<p>Figure: Scatter plot of <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> against the average calibrated quality score for rejected papers. To prevent reidentification of individual papers quality scores and citation count, each point is corrupted by differentially private noise in the plot (correlation is computed before adding differentially private noise).</p>
</div>
</div>
<p>Welling and Ghahramani introduced an “impact” score in NeurIPS 2013, we might expect the impact score to show correlation. And indeed, despite the lower range of the score (a reviewer can score either 1 or 2) we do see <em>some</em> correlation, although it is relatively weak.</p>
<div class="figure">
<div id="citations-vs-average-impact-accept-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/citations-vs-average-impact-accept.svg" width="70%" style=" ">
</object>
</div>
<div id="citations-vs-average-impact-accept-magnify" class="magnify" onclick="magnifyFigure(&#39;citations-vs-average-impact-accept&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="citations-vs-average-impact-accept-caption" class="caption-frame">
<p>Figure: Scatter plot of <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> against the average impact score for accepted papers. To prevent reidentification of individual papers quality scores and citation count, each point is corrupted by differentially private noise in the plot (correlation is computed before adding differentially private noise).</p>
</div>
</div>
<p>Finally, we also looked at correlation between the <em>confidence</em> score and the impact. Here correlation is somewhat stronger. Why should confidence be an indicator of higher citations? A plausible explanation is that there is confounder driving both variables. For example, it might be that papers which are easier to understand (due to elegance of the idea, or quality of exposition) inspire greater reviewer confidence and increase the number of citations.</p>
<div class="figure">
<div id="citations-vs-average-confidence-accept-figure" class="figure-frame">
<object class="svgplot " data="https://inverseprobability.com/talks/./slides/diagrams//neurips/citations-vs-average-confidence-accept.svg" width="70%" style=" ">
</object>
</div>
<div id="citations-vs-average-confidence-accept-magnify" class="magnify" onclick="magnifyFigure(&#39;citations-vs-average-confidence-accept&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="citations-vs-average-confidence-accept-caption" class="caption-frame">
<p>Figure: Scatter plot of <span class="math inline">\(\log_{10}(1+\text{citations})\)</span> against the average confidence score for accepted papers. To prevent reidentification of individual papers quality scores and citation count, each point is corrupted by differentially private noise in the plot (correlation is computed before adding differentially private noise).</p>
</div>
</div>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> column <span class="kw">in</span> [<span class="st">&quot;average_quality&quot;</span>, <span class="st">&quot;average_impact&quot;</span>, <span class="st">&quot;average_confidence&quot;</span>]:</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    cor <span class="op">=</span> []</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        ind <span class="op">=</span> bootstrap_index(joindf.loc[joindf.accept])</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>        cor.append(joindf.loc[ind][column].corr(np.log(<span class="dv">1</span><span class="op">+</span>joindf.loc[ind][<span class="st">&#39;numCitedBy&#39;</span>])))</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    cora <span class="op">=</span> np.array(cor)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> cora.mean()</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    twosd <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(cora.var())</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{column}</span><span class="st">&quot;</span>.<span class="bu">format</span>(column<span class="op">=</span>column.replace(<span class="st">&quot;_&quot;</span>, <span class="st">&quot; &quot;</span>)))</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Mean correlation is </span><span class="sc">{rho}</span><span class="st"> +/- </span><span class="sc">{twosd}</span><span class="st">&quot;</span>.<span class="bu">format</span>(rho<span class="op">=</span>rho, twosd<span class="op">=</span>twosd))</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-conclusion.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_neurips/includes/neurips-experiment-conclusion.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Under the simple model we have outlined, we can be confident that there is inconsistency between two independent committees, but the level of inconsistency is much less than we would find for a random committee. If we accept that the bias introduced by the Area Chairs knowing when they were dealing with duplicates was minimal, then if we were to revisit the NIPS 2014 conference with an independent committee then we would expect between <strong>38% and 64% of the presented papers to be the same</strong>. If the conference was run at random, then we would only expect 25% of the papers to be the same.</p>
<p>It’s apparent from comments and speculation about what these results mean, that some people might be surprised by the size of this figure. However, it only requires a little thought to see that this figure is likely to be large for any highly selective conference if there is even a small amount of inconsistency in the decision-making process. This is because once the conference has chosen to be ‘highly selective’ then because, by definition, only a small percentage of papers are to be accepted. Now if we think of a type I error as accepting a paper which should be rejected, such errors are easier to make because, again by definition, many more papers should be rejected. Type II errors (rejecting a paper that should be accepted) are less likely because (by setting the accept rate low) there are fewer papers that should be accepted in the first place. When there is a difference of opinion between reviewers, it does seem that many of the aruguments can be distilled down to (a subjective opinion) about whether controlling for type I or type II errors is more important. Further, normally when discussing type I and type II errors we believe that the underlying system of study is genuinely binary: e.g., diseased or not diseased. However, for conferences the accept/reject boundary is not a clear separation point, there is a continuum (or spectrum) of paper quality (as there also is for some diseases). And the decision boundary often falls in a region of very high density.</p>
<p>I would prefer a world were a conference is no longer viewed as a proxy for research quality. The true test of quality is time. In the current world, papers from conferences such as NeurIPS are being used to judge whether a researcher is worthy of a position at a leading company, or whether a researcher gets tenure. This is problematic and damaging for the community. Reviewing is an inconsistent process, but that is not a bad thing. It is far worse to have a reviewing system that is consistently wrong than one which is inconsistently wrong.</p>
<p>My own view of a NeurIPS paper is inspired by the Millenium Galleries in Sheffield. There, among the exhibitions they sometimes have work done by apprentices in their ‘qualification.’ Sheffield is known for knives, and the work of the apprentices in making knives is sometimes very intricate indeed. But it does lead to some very impractical knives. NeurIPS seems to be good at judging technical skill, but not impact. And I suspect the same is true of many other meetings. So, a publication a NeurIPS does seem to indicate that the author has some of the skills required, but it does not necessarily imply that the paper will be impactful.</p>
<h2 id="thanks">Thanks!</h2>
<p>For more information on these subjects and more you might want to check the following resources.</p>
<ul>
<li>twitter: <a href="https://twitter.com/lawrennd">@lawrennd</a></li>
<li>podcast: <a href="http://thetalkingmachines.com">The Talking Machines</a></li>
<li>newspaper: <a href="http://www.theguardian.com/profile/neil-lawrence">Guardian Profile Page</a></li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
<h1 id="references">References</h1>

